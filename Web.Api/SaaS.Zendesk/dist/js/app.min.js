"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

angular.module('app.auth', []);
angular.module('app.services', []);
angular.module('app.controllers', []);
angular.module('app.directives', []);
angular.module('app.filters', []);
angular.module('app', ['ui.router', 'app.auth', 'app.services', 'app.controllers', 'app.directives', 'app.filters']).run(function ($trace, $transitions, $auth, $brand) {
  $trace.enable('TRANSITION');
  $transitions.onBefore({
    to: '**'
  }, function (transitions) {
    if (transitions.to().isProtected && !$auth.isAuthenticated()) {
      var query = {};
      if (!$brand.isEmpty()) query.brandId = $brand.get().id;
      return transitions.router.stateService.target('user/sign-in', query);
    }
  });
}).config(function ($stateProvider, $urlRouterProvider) {
  // $locationProvider.html5Mode({
  //     enabled: true,
  //     requireBase: false
  // });
  $urlRouterProvider.otherwise('/en/index');
  $stateProvider.state('app', {
    url: '/:locale',
    //templateUrl: 'index.html',
    restricted: false,
    abstract: true,
    views: {
      sidebar: {
        controller: 'partialSidebarController',
        templateUrl: 'partial/sidebar.html'
      },
      content: {
        controller: 'appController'
      }
    }
  });

  var _state = function _state(json) {
    json.name = json.name || json.url;
    json.params = json.params || {};
    json.templateUrl = json.templateUrl || "views/".concat(json.url, ".html");
    json.isProtected = !!json.isProtected;
    var state = {
      parent: 'app',
      url: "/".concat(json.url),
      params: json.params,
      templateUrl: json.templateUrl,
      controller: "".concat(json.controller, "Controller"),
      isProtected: json.isProtected
    };
    $stateProvider.state(json.name, state);
  };

  _state({
    url: 'index',
    controller: 'index'
  });

  _state({
    url: 'account',
    controller: 'account',
    templateUrl: 'views/account/index.html',
    params: {
      accountId: null,
      brandId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/external-session-tokens',
    controller: 'accountExternalSessionTokens',
    params: {
      accountId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/product',
    controller: 'accountProduct',
    params: {
      accountId: null,
      accountProductId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/products',
    controller: 'accountProducts',
    params: {
      accountId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/sub-emails',
    controller: 'accountSubEmails',
    params: {
      accountId: null
    },
    isProtected: true
  });

  _state({
    url: 'account/email-is-empty',
    controller: 'accountEmailIsEmpty',
    params: {
      email: null
    },
    isProtected: true
  });

  _state({
    url: 'account/not-found',
    controller: 'accountNotFound',
    params: {
      email: null
    },
    isProtected: true
  });

  _state({
    url: 'brand/not-supported',
    controller: 'brandNotSupported',
    params: {
      brandId: null
    }
  });

  _state({
    url: 'ticket/not-found',
    controller: 'ticketNotFound'
  });

  _state({
    url: 'ticket/requester-email-is-empty',
    controller: 'ticketRequesterEmailIsEmpty'
  });

  _state({
    url: 'user/sign-in',
    controller: 'userSignIn',
    params: {
      brandId: null
    }
  });

  _state({
    url: 'zat/client-not-found',
    controller: 'zatClientNotFound'
  });
}); //https://github.com/modularcode/modular-admin-angularjs/blob/master/src/_main.js

angular.module('app').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push([function () {
    var interceptor = {};

    interceptor.response = function (response) {
      var config = response.config || {};
      if (config.asJson === true) return response.data;
      return response;
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$auth', ['$q', '$state', '$injector', '$authStorage', '$brand', function ($q, $state, $injector, $authStorage, $brand) {
  var _apiHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };
  var service = {};

  var _getItem = function _getItem() {
    var iso = $brand.getIso();
    return $authStorage.getItem(iso);
  };

  service.isAuthenticated = function () {
    if ($brand.isEmpty()) return false;
    return !!_getItem();
  };

  service.getAccessToken = function () {
    var item = _getItem();

    return item ? item.access_token : null;
  };

  service.getRefreshToken = function () {
    var item = _getItem();

    return item ? item.refresh_token : null;
  };

  service.signIn = function (login, password) {
    var $http = $injector.get("$http");
    var data = ['grant_type=password', 'username=' + encodeURIComponent(login), 'password=' + encodeURIComponent(password)];
    data = data.join('&');
    var deferred = $q.defer();

    if ($brand.isEmpty()) {
      deferred.reject({
        error_description: 'Brand is not supported!'
      });
    } else {
      var uri = $brand.getApiUri('api/token');
      $http.post(uri, data, {
        headers: _apiHeaders,
        asJson: true
      }).then(function (json) {
        var iso = $brand.getIso();
        $authStorage.setItem(iso, json);
        deferred.resolve(json);
      }, function (error, status, headers) {
        deferred.reject(error.data);
      });
    }

    return deferred.promise;
  };

  service.refreshToken = function () {
    var $http = $injector.get("$http");
    var data = ['grant_type=refresh_token', 'refresh_token=' + service.getRefreshToken()];
    data = data.join('&');
    var deferred = $q.defer();
    var uri = $brand.getApiUri('api/token');
    $http.post(uri, data, {
      headers: _apiHeaders,
      asJson: true
    }).then(function (json) {
      var iso = $brand.getIso();
      $authStorage.setItem(iso, json);
      deferred.resolve(json);
    }, function (error, status, headers) {
      service.logout();
      deferred.reject(status);
    });
    return deferred.promise;
  };

  service.logout = function () {
    var iso = $brand.getIso();
    $authStorage.removeItem(iso);
    $state.go('user/sign-in');
  };

  return service;
}]);
angular.module('app.auth').factory('$authBuffer', ['$injector', function ($injector) {
  /** Holds all the requests, so they can be re-requested in future. */
  var _buffer = [];
  /** Service initialized later because of circular dependency problem. */

  var $http;

  var _retryHttpRequest = function _retryHttpRequest(config, deferred) {
    var _success = function _success(response) {
      deferred.resolve(response);
    };

    var _error = function _error(response) {
      deferred.reject(response);
    };

    $http = $http || $injector.get('$http');
    $http(config).then(_success, _error);
  };

  var service = {};
  /**
  * Appends HTTP request configuration object with deferred response attached to buffer.
  */

  service.append = function (config, deferred) {
    _buffer.push({
      config: config,
      deferred: deferred
    });
  };
  /**
  * Abandon or reject (if reason provided) all the buffered requests.
  */


  service.rejectAll = function (reason) {
    if (reason) {
      for (var index = 0; index < _buffer.length; ++index) {
        _buffer[index].deferred.reject(reason);
      }
    }

    _buffer = [];
  };
  /**
   * Retries all the buffered requests clears the buffer.
   */


  service.retryAll = function (updater) {
    for (var index = 0; index < _buffer.length; ++index) {
      _retryHttpRequest(updater(_buffer[index].config), _buffer[index].deferred);
    }

    _buffer = [];
  };

  return service;
}]);
angular.module('app.auth').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', '$auth', '$authInterceptor', '$authBuffer', function ($q, $auth, $authInterceptor, $authBuffer) {
    var interceptor = {};

    interceptor.request = function (config) {
      config.headers = config.headers || {};
      if (config.isOauth) config.headers.Authorization = 'bearer ' + $auth.getAccessToken();
      return config;
    };

    interceptor.responseError = function (rejection) {
      var config = rejection.config || {};

      switch (rejection.status) {
        case 401:
          var deferred = $q.defer();
          $authBuffer.append(config, deferred);
          $auth.refreshToken().then($authInterceptor.loginConfirmed, $auth.logout);
          return deferred.promise;
      }

      return $q.reject(rejection);
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$authInterceptor', ['$authBuffer', function ($authBuffer) {
  var service = {};
  /**
  * Call this function to indicate that authentication was successfull and trigger a
  * retry of all deferred requests.
  * @param data an optional argument to pass on to $broadcast which may be useful for
  * example if you need to pass through details of the user that was logged in
  * @param configUpdater an optional transformation function that can modify the
  * requests that are retried after having logged in.  This can be used for example
  * to add an authentication token.  It must return the request.
  */

  service.loginConfirmed = function (data, configUpdater) {
    var updater = configUpdater || function (config) {
      return config;
    };

    $authBuffer.retryAll(updater);
  };
  /**
   * Call this function to indicate that authentication should not proceed.
   * All deferred requests will be abandoned or rejected (if reason is provided).
   * @param data an optional argument to pass on to $broadcast.
   * @param reason if provided, the requests are rejected; abandoned otherwise.
   */


  service.loginCancelled = function (data, reason) {
    $authBuffer.rejectAll(reason);
  };

  return service;
}]);
angular.module('app.auth').factory('$authStorage', ['$window', function ($window) {
  var _localStorage = {};

  var _getItem = function _getItem(key) {
    var json = _localStorage[key];
    var value = json ? JSON.parse(json) : null;
    _localStorage[key] = json;

    try {
      json = $window.localStorage.getItem(key);
      json && (value = JSON.parse(json));
    } catch (error) {
      console.error(error);
    }

    return value;
  };

  var _setItem = function _setItem(key, value) {
    var json = JSON.stringify(value);
    _localStorage[key] = json;

    try {
      $window.localStorage.setItem(key, json);
    } catch (error) {
      console.error(error);
    }
  };

  var _removeItem = function _removeItem(key) {
    delete _localStorage[key];

    try {
      $window.localStorage.removeItem(key);
    } catch (error) {
      console.error(error);
    }
  };

  var service = {};

  service.getItem = function (brandIso) {
    return _getItem("auth:".concat(brandIso));
  };

  service.setItem = function (brandIso, json) {
    _setItem("auth:".concat(brandIso), json);
  };

  service.removeItem = function (brandIso) {
    _removeItem("auth:".concat(brandIso));
  };

  return service;
}]);
angular.module('app.controllers').controller('appController', ['$scope', '$state', '$zendesk', '$brand', '$auth', function ($scope, $state, $zendesk, $brand, $auth) {
  $zendesk.init();
  if ($zendesk.isEmpty()) return $state.go('zat/client-not-found');

  var _validateBrand = function _validateBrand(brand) {
    $brand.set(brand);
    if (!$brand.isSupport()) return $state.go('brand/not-supported', {
      brandId: brand.id
    });
    $scope.$auth = $auth;
    $state.go('account', {
      brandId: brand.id
    });
  };

  $zendesk.get(['ticket.brand']).then(function (response) {
    _validateBrand(response['ticket.brand']);
  }, function () {
    $state.go('ticket/not-found');
  });
  $zendesk.on('ticket.brand.changed', _validateBrand);
}]);
angular.module('app.controllers').controller('indexController', ['$scope', function ($scope) {}]);
angular.module('app.directives').directive('ngDate', ['$filter', function ($filter) {
  return {
    restrict: 'A',
    scope: {
      date: '=ngDate',
      format: '=ngFormat'
    },
    link: function link(scope, element, attrs) {
      if (!scope.date) return;
      element.addClass('text-muted small');
      var format = scope.format || 'yyyy-MM-dd';
      /* HH:mm*/

      scope.$watch('date', function (newValue, oldValue) {
        if (newValue || newValue != oldValue) element.html("<em>" + $filter('date')(scope.date, format) + "</em>");
      });
    }
  };
}]);
angular.module('app.directives').directive('ngExternalConnectedAccountStatus', [function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.addClass('fas');

      if (attrs.ngExternalConnectedAccountStatus === 'false') {
        element.addClass('fa-user-slash text-danger').attr('title', 'Disconnected');
      } else {
        element.addClass('fa-user text-success').attr('title', 'Connected');
      }
    }
  };
}]);
angular.module('app.directives').directive('ngExternalConnectedAccount', [function () {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.addClass('fab').addClass('fa-' + attrs.ngExternalConnectedAccount);

      switch (attrs.ngExternalConnectedAccount) {
        case 'google':
          element.css({
            color: '#d62d20'
          });
          break;

        case 'facebook':
          element.css({
            color: '#3b5998'
          });
          break;

        case 'microsoft':
          element.css({
            color: '#00a1f1'
          });
          break;
      }
    }
  };
}]);
angular.module('app.directives').directive('ngSidebar', ['$rootScope', '$api', function ($rootScope, $api) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      var sidebar = element.find('.sidebar:first, .sidebar-content');
      var buttons = element.find('button.navbar-toggler');
      buttons.eq(0).bind('click', function () {
        sidebar.css({
          height: '100%'
        });
      }); // element.find('.btn').bind('click', function () {
      //     sidebar.css({ height: '0%' });
      // })

      buttons.eq(1).bind('click', function () {
        sidebar.css({
          height: '0%'
        });
      });
      var cleanup = $rootScope.$on('event:closeSidebar', function () {
        sidebar.css({
          height: '0%'
        });
      });
      scope.$on('$destroy', cleanup);
    }
  };
}]);
angular.module('app.directives').directive('ngSpinner', ['$rootScope', function ($rootScope) {
  return {
    restrict: 'E',
    replace: true,
    template: '<div class="spinner" style="display:none"></div>',
    link: function link(scope, element, attrs) {
      $rootScope.$on('event:spinner-show', function () {
        element.show();
      });
      $rootScope.$on('event:spinner-hide', function () {
        element.hide();
      }); //scope.$on('$destroy', cleanup);
    }
  };
}]);
angular.module('app.services').factory('$api', ['$http', '$brand', function factory($http, $brand) {
  var _config = {
    asJson: true,
    isOauth: true
  };
  var _accountStatusEnum = {
    none: 0,
    isActivated: 1 << 0,
    isAnonymous: 1 << 1,
    isBusiness: 1 << 2
  };
  ;
  var _productStatusEnum = {
    none: 0,
    isDisabled: 1 << 0,
    isExpired: 1 << 1,
    isTrial: 1 << 2,
    isFree: 1 << 3,
    isMinor: 1 << 4,
    isDefault: 1 << 5,
    isPPC: 1 << 6,
    isUpgradable: 1 << 7,
    isNew: 1 << 8,
    isPaymentFailed: 1 << 9,
    isRenewal: 1 << 10,
    isOwner: 1 << 11,
    IsNotAbleToRenewCreditCartExpired: 1 << 12
  };
  var service = {};
  service.account = {
    isActivated: function isActivated(account) {
      return !!(account.status & _accountStatusEnum.isActivated);
    },
    isBusiness: function isBusiness(account) {
      return !!(account.status & _accountStatusEnum.isBusiness);
    },
    get: function get(params) {
      var method = 'api/account/';

      if (params.accountId) {
        method += params.accountId;
        delete params.accountId;
      }

      var config = angular.copy(_config);
      config.params = params;
      return $http.get($brand.getApiUri(method), config);
    }
  };
  service.product = {
    isDisabled: function isDisabled(product) {
      return !!(product.status & _productStatusEnum.isDisabled);
    },
    isTrial: function isTrial(product) {
      return !!(product.status & _productStatusEnum.isTrial);
    },
    isFree: function isFree(product) {
      return !!(product.status & _productStatusEnum.isFree);
    },
    isPPC: function isPPC(product) {
      return !!(product.status & _productStatusEnum.isPPC);
    },
    isRenewal: function isRenewal(product) {
      return !!(product.status & _productStatusEnum.isRenewal);
    },
    isOwner: function isOwner(product) {
      return !!(product.status & _productStatusEnum.isOwner);
    }
  };

  service.account.getSubEmails = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/sub-email")), _config);
  };

  service.account.removeSubEmail = function (params) {
    return $http.delete($brand.getApiUri("api/account/".concat(params.accountId, "/sub-email/").concat(params.id)), _config);
  };

  service.account.getExternalSessionTokens = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/external/session-token")), _config);
  };

  service.account.getOwnerProducts = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/owner-product")), _config);
  };

  service.account.getOwnerProductDetails = function (params) {
    return $http.get($brand.getApiUri("api/account/".concat(params.accountId, "/owner-product/").concat(params.accountProductId)), _config);
  };

  return service;
}]);
angular.module('app.services').factory('$brand', function () {
  var _brands = {
    sodapdf: {
      api: 'https://cp-oauth.sodapdf.com'
    },
    pdfarchitect: {
      api: 'https://cp-oauth.pdfarchitect.org'
    }
  };
  var _brand = null;
  var service = {};

  service.isEmpty = function () {
    return !_brand;
  };

  service.set = function (brand) {
    _brand = brand;
  };

  service.get = function () {
    return _brand;
  };

  service.isSupport = function () {
    var iso = service.getIso(_brand);
    return !!_brands[iso];
  };

  service.getIso = function () {
    return _brand.subdomain;
  };

  service.getApiUri = function (method) {
    var iso = service.getIso();
    var api = _brands[iso].api;
    return "".concat(api, "/").concat(method);
  };

  service.getLogo = function () {
    if (service.isEmpty()) return null;
    return _brand.logo.contentUrl;
  };

  return service;
});
angular.module('app.services').factory('$form', function () {
  var service = {};

  service.submit = function (entity, form, callback) {
    if (form.$valid !== true) {
      angular.forEach(form, function (value, key) {
        if (_typeof(value) === 'object' && value.hasOwnProperty('$modelValue')) value.$setDirty();
      });
    }

    if (service.isReady(entity, form) === false) return;
    callback(form);
  };

  service.isReady = function (entity, form) {
    if (entity.isBusy === true || form.$valid !== true) return false;
    entity.isBusy = true;
    return true;
  };

  return service;
});
angular.module('app.services').factory('$zendesk', [function () {
  var _zClient = ZAFClient.init();

  var service = {};

  service.init = function () {
    _zClient && _zClient.invoke('resize', {
      width: '100%',
      height: '400px'
    });
  };

  service.isEmpty = function () {
    return !_zClient;
  };

  service.on = function (key, callback) {
    return _zClient.on(key, callback);
  };

  service.get = function (key) {
    return _zClient.get(key);
  };

  return service;
}]);
angular.module('app.controllers').controller('accountController', ['$rootScope', '$q', '$scope', '$state', '$api', '$zendesk', function ($rootScope, $q, $scope, $state, $api, $zendesk) {
  $scope.model = {
    accountId: null,
    account: null
  };

  var _getAccount = function _getAccount() {
    var params = $state.params;
    var deferred = $q.defer();

    if (params.accountId) {
      $api.account.get({
        accountId: params.accountId
      }).then(deferred.resolve, function () {
        deferred.reject({
          state: 'account/not-found',
          params: {
            accountId: params.accountId
          }
        });
      });
    } else {
      $zendesk.get(['ticket.requester']).then(function (response) {
        var requester = response['ticket.requester'];
        if (!requester.email) deferred.reject({
          state: 'account/email-is-empty'
        });else {
          $api.account.get({
            email: requester.email
          }).then(deferred.resolve, function () {
            deferred.reject({
              state: 'account/not-found',
              params: {
                email: requester.email
              }
            });
          });
        }
      }, function () {
        deferred.reject({
          state: 'ticket/requester-email-is-empty'
        });
      });
    }

    return deferred.promise;
  };

  $rootScope.$broadcast('event:spinner-show');

  _getAccount().then(function (json) {
    $scope.model.account = json;
    $scope.model.accountId = json.id;
  }, function (error) {
    $state.go(error.state, error.params);
  }).finally(function () {
    $rootScope.$broadcast('event:spinner-hide');
  });
}]);
angular.module('app.controllers').controller('accountEmailIsEmptyController', ['$scope', function ($scope) {}]);
angular.module('app.controllers').controller('accountExternalSessionTokensController', ['$scope', '$state', '$api', function ($scope, $state, $api) {
  $scope.isLoading = true;
  $scope.model = {
    accountId: $state.params.accountId,
    externalSessionTokens: null
  };
  $api.account.getExternalSessionTokens({
    accountId: $scope.model.accountId
  }).then(function (json) {
    $scope.model.externalSessionTokens = json;
  });
}]);
angular.module('app.controllers').controller('accountNotFoundController', ['$scope', '$state', '$brand', function ($scope, $state, $brand) {
  $scope.model = {
    email: $state.params.email,
    logo: $brand.get().logo.contentUrl
  };
}]);

(function () {
  angular.module('app.controllers').controller('accountProductController', ['$scope', '$state', '$api', function ($scope, $state, $api) {
    $scope.$api = $api;
    $scope.isLoading = true;
    $scope.model = {
      accountId: $state.params.accountId,
      accountProductId: $state.params.accountProductId,
      product: null
    };
    var query = {
      accountId: $scope.model.accountId,
      accountProductId: $scope.model.accountProductId
    };
    $api.account.getOwnerProductDetails(query).then(function (json) {
      $scope.model.product = new viewProduct(json);
    });
  }]);

  var viewProduct = function viewProduct(json) {
    Object.defineProperties(this, {
      id: {
        value: json.id,
        writable: false
      },
      name: {
        value: json.name,
        writable: false
      },
      unitName: {
        value: json.unitName,
        writable: false
      },
      plan: {
        value: json.plan,
        writable: false
      },
      ownerEmail: {
        value: json.ownerEmail,
        writable: false
      },
      allowed: {
        value: json.allowed,
        writable: false
      }
    });
    this.endDate = json.endDate;
    this.purchaseDate = json.purchaseDate;
    this.status = json.status;
    this.accounts = viewAcountBuilder.build(json);
  };

  var viewAccount = function viewAccount(json) {
    Object.defineProperties(this, {
      accountId: {
        value: json.accountId,
        writable: false
      },
      email: {
        value: json.email,
        writable: false
      }
    });
  };

  var viewAcountBuilder = function viewAcountBuilder() {};

  viewAcountBuilder.build = function (json) {
    var accounts = [];

    if (json.accounts) {
      for (var index = 0; index < json.accounts.length; index++) {
        var account = json.accounts[index];
        accounts.push(new viewAccount(account));
      }
    }

    return accounts;
  };
})();

(function () {
  angular.module('app.controllers').controller('accountProductsController', ['$scope', '$state', '$api', function ($scope, $state, $api) {
    $scope.$api = $api;
    $scope.isLoading = true;
    $scope.model = {
      accountId: $state.params.accountId,
      products: null
    };
    $api.account.getOwnerProducts({
      accountId: $scope.model.accountId
    }).then(function (json) {
      $scope.model.products = viewProductBuilder.build(json, $api);
    });
  }]);

  var viewProduct = function viewProduct(json, $api) {
    Object.defineProperties(this, {
      id: {
        value: json.id,
        writable: false
      },
      name: {
        value: json.name,
        writable: false
      },
      unitName: {
        value: json.unitName,
        writable: false
      },
      plan: {
        value: json.plan,
        writable: false
      },
      allowed: {
        value: json.allowed,
        writable: false
      },
      purchaseDate: {
        value: json.purchaseDate,
        writable: false
      },
      status: {
        value: json.status,
        writable: false
      }
    });
    this.$api = $api;
  };

  viewProduct.prototype.getTableCssClass = function () {
    var $api = this.$api;
    if ($api.product.isDisabled(this)) return 'table-danger';
    if ($api.product.isFree(this) || $api.product.isTrial(this)) return 'table-primary';
    return '';
  };

  var viewProductBuilder = function viewProductBuilder() {};

  viewProductBuilder.build = function (json, $api) {
    var products = [];

    for (var index = 0; index < json.length; index++) {
      products.push(new viewProduct(json[index], $api));
    }

    return products;
  };
})();

angular.module('app.controllers').controller('accountSubEmailsController', ['$scope', '$state', '$api', function ($scope, $state, $api) {
  $scope.isLoading = true;
  $scope.model = {
    accountId: $state.params.accountId,
    subEmails: null
  };

  $scope.refresh = function () {
    $api.account.getSubEmails({
      accountId: $scope.model.accountId
    }).then(function (json) {
      $scope.model.subEmails = json;
    });
  };

  $scope.remove = function (json) {
    $api.account.removeSubEmail(json).finally($scope.refresh);
  };
}]);
angular.module('app.controllers').controller('brandNotSupportedController', ['$scope', '$brand', function ($scope, $brand) {
  $scope.model = {
    logo: $brand.get().logo.contentUrl
  };
}]);
angular.module('app.controllers').controller('partialSidebarController', ['$rootScope', '$scope', '$auth', '$state', '$api', '$form', function ($rootScope, $scope, $auth, $state, $api, $form) {
  $scope.$auth = $auth;
  var _search = {
    filter: null
  };
  $scope.model = {
    search: {
      filter: null
    }
  };
  $scope.status = null;
  $scope.isBusy = false;

  $scope.search = function (form) {
    $form.submit($scope, form, function () {
      $scope.status = null;
      _search.filter = $scope.model.search.filter;
      if (!_search.filter) return;
      var query = {};
      if (_search.filter.indexOf('@') !== -1) query.email = _search.filter;else query.transactionOrderUid = _search.filter;
      $scope.isBusy = true;
      $api.account.get(query).then(function (json) {
        $rootScope.$broadcast('event:closeSidebar');
        return $state.go('account', {
          accountId: json.id
        });
      }, function (error) {
        $scope.status = error.status;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };

  $scope.signIn = function () {
    $state.go('user/sign-in');
    $rootScope.$broadcast('event:closeSidebar');
  };

  $scope.logout = function () {
    $auth.logout();
    $rootScope.$broadcast('event:closeSidebar');
  };
}]);
angular.module('app.controllers').controller('ticketNotFoundController', ['$scope', function ($scope) {}]);
angular.module('app.controllers').controller('userSignInController', ['$scope', '$brand', '$state', '$auth', '$form', '$zendesk', function ($scope, $brand, $state, $auth, $form, $zendesk) {
  $scope.model = {
    logo: $brand.getLogo(),
    avatar: null,
    error: null
  };
  $scope.status = null;
  $scope.isBusy = false;
  !$zendesk.isEmpty() && $zendesk.get('currentUser').then(function (response) {
    $scope.model.login = response.currentUser.email;
    $scope.model.avatar = response.currentUser.avatarUrl;
    $scope.$apply();
  });

  $scope.submit = function (form) {
    $scope.model.error = null;
    $form.submit($scope, form, function () {
      return $auth.signIn($scope.model.login, $scope.model.password).then(function () {
        $state.go('account');
      }, function (json) {
        $scope.model.error = json.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('zatClientNotFoundController', ['$scope', function ($scope) {}]);
angular.module('app.directives').directive('ngAccountActivated', ['$api', function ($api) {
  return {
    restrict: 'A',
    scope: {
      status: '=ngAccountActivated'
    },
    link: function link(scope, element, attrs) {
      element.addClass('badge');
      var watch = scope.$watch('status', function () {
        element.removeClass('badge-warning').removeClass('badge-success');
        !$api.account.isActivated(scope) && element.addClass('badge-warning').text('not activated');
        $api.account.isActivated(scope) && element.addClass('badge-success').text('activated');
      });
      scope.$on("$destroy", function () {
        watch();
      });
    }
  };
}]);
angular.module('app.directives').directive('ngAccountMenu', ['$state', function ($state) {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: 'directives/account/menu.html'
  };
}]);
angular.module('app.directives').directive('ngAccountType', ['$api', function ($api) {
  return {
    restrict: 'A',
    scope: {
      status: '=ngAccountType'
    },
    link: function link(scope, element, attrs) {
      element.addClass('badge');
      var watch = scope.$watch('status', function () {
        element.removeClass('badge-primary').removeClass('badge-info');
        !$api.account.isBusiness(scope) && element.addClass('badge-info').text('b2c');
        $api.account.isBusiness(scope) && element.addClass('badge-primary').text('b2b');
      });
      scope.$on("$destroy", function () {
        watch();
      });
    }
  };
}]);
angular.module('app.directives').directive('ngProductOwner', ['$api', function ($api) {
  return {
    restrict: 'A',
    scope: {
      status: '=ngProductOwner'
    },
    link: function link(scope, element, attrs) {
      element.addClass('badge');
      var watch = scope.$watch('status', function (status) {
        if (!status) return;
        element.removeClass('badge-warning').removeClass('badge-success');
        !$api.product.isOwner(scope) && element.addClass('badge-danger').text('not owner');
        $api.product.isOwner(scope) && element.addClass('badge-success').text('owner');
      });
      scope.$on("$destroy", function () {
        watch();
      });
    }
  };
}]);